public class C {
	private D d;
	
	void f(B b) {
		b.call()
		g();
		d.call();
	}
	
	void g() {
		A a = new A();
		a.call()
	}
}

/**
* Demeter of LoD의 개념: 객체마다 Data를 숨겨서 Dependency를 낮추자는 규칙
-> 한 객체를 수정할 때마다 다른 객체들이 영향을 받으면 안됨
-> a.b().c()와 같은 호출구조를 가지면 안된다 == A가 B를 통해 C에 접근할 수 있으면 안된다

* 클래스 C에 대해 호출 가능한 구조를 설명하는 코드가 위에 제시된 코드이다.
- 응집도 측면에서 class C는 멤버변수 d에 대해 자주 접근하는 것이 좋다.
- 또한 class C의 메서드인 f의 파라미터로 받는 b에 대해서도 접근이 가능하며, 이는 b의 메서드를 호출하는 행위도 포함된다
- 파라미터 뿐 아니라 메서드 g와 같이 함수 내부에서 생성된 객체(ex. a)에 대해서도 접근(ex. 메서드 호출)이 가능하다
- 마지막으로 내부 함수들이 서로 자신을 호출하는 행위(ex. f 메서드 내부에서 g 메서드를 호출하는 행위)도 가능하다 
*/

